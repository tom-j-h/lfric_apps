! *****************************COPYRIGHT**************************************
! (C) Crown copyright Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
! *****************************COPYRIGHT**************************************
!  data module for switches/options concerned with the cloud scheme.
  ! Description:
  !   Module containing runtime options/data used by the cloud scheme
  !
  ! Method:
  !   Switches and associated data values used by the cloud scheme
  !   are defined here and assigned default values. These may be overridden
  !   by namelist input.
  !
  !   A description of what each switch or number refers to is provided
  !   with the namelist
  !
  !   Any routine wishing to use these options may do so with the 'use'
  !   statement.
  !
  ! Code Owner: Please refer to the UM file CodeOwners.txt
! This file belongs in section: large_scale_cloud
  !
  ! Code Description:
  !   Language: FORTRAN 90
  !

module cloud_inputs_mod

use missing_data_mod, only: rmdi, imdi
use atmos_max_sizes,  only: model_levels_max
use yomhook,  only: lhook, dr_hook
use parkind1, only: jprb, jpim
use errormessagelength_mod, only: errormessagelength

use um_types, only: real_umphys, real_eps

implicit none

!===========================================================================
! integer options set from RUN_CLOUD namelist
!===========================================================================

integer :: i_cld_vn = imdi
! Which cloud scheme are we using - Off (microphysics only), Smith of PC2

integer :: falliceshear_method = imdi
                                       ! Select method for including
                                       ! effects of shear on falling
                                       ! ice effecting CFF.

integer :: i_pc2_conv_coupling = imdi  ! Integer option to determine how the
                                       ! PC2 cloud scheme and the convection
                                       ! scheme are coupled and how cloud gets
                                       ! generated by convection.

integer :: i_pc2_erosion_method = imdi ! Select method for calculating
                                       ! PC2 cloud erosion.

integer :: i_pc2_erosion_numerics = imdi  ! Select numerical method for time
                                          ! integration of PC2 cloud erosion

integer :: forced_cu = imdi            ! Select option for representing
                                       ! forced cumulus

integer :: i_rhcpt = imdi              ! Controls the use of RHcrit
                                       ! parametrization options
integer :: i_cld_area  = imdi          ! Controls cloud area parametrization

integer :: i_pc2_checks_cld_frac_method = imdi  ! Options for changing CFL and CF
                                       ! when creating extra
                                       ! QCL when qv>qsat.

integer, parameter :: all_clouds = 1   ! Use eacf for all cloud fractions
integer, parameter :: not_mixph = 2    ! Restrict usage in mixed-phase regions
integer :: i_eacf = imdi               ! Use empirically adjusted
                                       ! cloud fraction
integer :: i_pc2_init_method = imdi    ! Integer option to determine how to
                                       ! initate cloud in the PC2 cloud scheme
integer :: i_pc2_homog_g_method = imdi ! Switch for alternative methods of
                                       ! calculating the amplitude of the
                                       ! moisture PDF at the saturation
                                       ! boundary, in the PC2 homogeneous
                                       ! forcing calculations.
integer :: i_pc2_init_logic = imdi     ! Options for where to allow PC2
                                       ! initiation to operate
integer, parameter :: smith_orig = 1      ! original smith scheme method for
                                          ! ice cloud fraction method
integer, parameter :: cloud_top_temp = 2  ! Wilson method based on cloud top
                                          ! temperature (not recommended)
integer, parameter :: min_liq_overlap = 3 ! method in appendix of Abel et al
                                          ! (2017, JAS), based on minimising
                                          ! the overlap with the liquid phase
integer, parameter :: min_liq_overlap_local=4 ! For BiModal, an old erroneous
                                          ! implementation of 3 using only the
                                          ! local cfl instead of the max above
integer :: ice_fraction_method = imdi     ! Selects ice cloud fraction
                                          ! calculation method

integer :: i_bm_ez_opt = imdi          ! Options for bimodal cloud scheme
                                       ! entrainment zones
integer, parameter :: i_bm_ez_orig = 1    ! Original model-level diagnosis
                                          ! of entrainment zones based on
                                          ! local maxima in the theta gradient
integer, parameter :: i_bm_ez_subcrit = 2 ! As 1, but entrainment zones must
                                          ! be turbulent (Ri < Ri_crit).
integer, parameter :: i_bm_ez_entpar = 3  ! Construct modes from above and
                                          ! below using entraining parcels

!===========================================================================
! logical options set from RUN_CLOUD namelist
!===========================================================================

logical :: l_ensure_min_in_cloud_qcf = .false.
                                 ! Reduce CFF when qcf is low to
                                 ! ensure a minimum qcf/CFF.

logical :: l_micro_eros = .false.
                                 ! If false, erosion is done as part of
                                 ! the convection scheme
                                 ! If true, erosion is done as part of
                                 ! the microphysics scheme

logical :: l_pc2_lbc = .false.   ! LBCs contain cloud fractions

logical :: l_add_cca_to_mcica = .false.
                                 ! Add the convective cloud amount to McICA
                                 ! so that radiation sees the convective cores.

logical :: l_od_cld_filter = .false.
                                 ! Filters area and combined cloud amounts
                                 ! to remove sub-visual cirrus
                                 ! (based on optical depth, od) prior to
                                 ! calculating low/med/high and
                                 ! total cloud amounts.
logical :: l_ceil_cld_filter=.false.
                                 ! Filters cloud that cannot be seen by
                                 ! ceilometers simply setting cloud cover to
                                 ! zero above the maximum height ceilometers
                                 ! can detect them. The height is set by
                                 ! "ceilometer_range" below.
logical :: l_sharpen_cbh_diags=.false.
                                 ! Modify the CBH diagnostics in a manner
                                 ! consistent with sharpening the humidity PDF
                                 ! and with sharpening the clear/cloud boundary
logical :: l_pc2_check_init=.false.
                                 ! Always run pc2_checks when the model is
                                 ! initialised
logical :: l_subgrid_qv=.false.
                                 ! Allow subgrid partitioning of water vapor
                                 ! between clear-sky and sublimating/depositing
                                 ! ice-cloud regions. This is used in the
                                 ! microphysics to calculate the processes rates
logical :: l_pc2_sl_advection=.false.
                                 ! Switch to do homogeneous forcing of liquid
                                 ! cloud by Lagrangian pressure change under
                                 ! advection (i.e. do it straight after the
                                 ! call to SL advection, instead of lumping
                                 ! it together with the Eulerian pressure
                                 ! forcing from the solver as by default).
logical :: l_pc2_homog_conv_pressure=.false.
                                 ! Switch to do homogeneous forcing of liquid
                                 ! cloud by convection using the pressure
                                 ! forcing method based on the convective
                                 ! environmental subsidence, consistent
                                 ! with the homogeneous forcing from advection.
logical :: l_cloud_call_b4_conv=.false.
                                 ! Switch to perform an extra call to the
                                 ! large-scale cloud scheme before the
                                 ! call to convection in atmos_physics2,
                                 ! to ensure the latest T,q,qcl,cf seen by
                                 ! convection are consistent with the cloud
                                 ! scheme's assumptions.
                                 ! For PC2, this entails an extra call to PC2
                                 ! checks and PC2 initiation before convection.
                                 ! For diagnostic cloud schemes, this only
                                 ! updates the "latest" cloud fraction fields
                                 ! passed into convection; the primary fields
                                 ! for the cloud fractions are still calculated
                                 ! in ni_imp_ctl as usual.
logical, parameter :: l_inc_cld_prec=.true.
                                 ! Allow call to the Smith cloud scheme from
                                 ! within the large-scale precipitation scheme.
logical :: l_bm_sigma_s_grad=.false.
                                 ! Account for local vertical gradients in
                                 ! the calculation of sub-grid saturation
                                 ! variance in the bimodal cloud scheme /
                                 ! bimodal initiation in PC2.
logical :: l_bm_tweaks=.false.
                                 ! Make several miscellaneous minor tweaks
                                 ! to the bimodal cloud-scheme:
                                 ! a) Impose a minimum limit on the turbulent
                                 !    moisture variance, consistent with the
                                 !    limit already imposed when determining
                                 !    where condensation should occur.
                                 ! b) Truncate the Gaussian distributions at
                                 !    max_sigmas standard deviations,
                                 !    consistent with the logic determining
                                 !    where condensation should occur.
                                 ! c) Add extra checks to prevent the scheme
                                 !    from predicting negative qcl where
                                 !    q is negative.
                                 ! d) Also avoid negative qcl resulting from
                                 !    floating point rounding error in a
                                 !    calculation of mixed-phase fraction.

!=======================================================================
! real values set from RUN_CLOUD namelist
!=======================================================================

real(kind=real_umphys)    :: dbsdtbs_turb_0 = rmdi
                                      ! PC2 erosion rate / s-1
real(kind=real_umphys)    :: starticeTKelvin = rmdi
                                      ! Temperature at which detrained
                                      ! condensate is assumed to start
                                      ! being in the ice phase (Kelvin)
real(kind=real_umphys)    :: alliceTdegC = rmdi
                                      ! Temperature at which all
                                      ! detrained condensate is
                                      ! assumed to be ice (deg C)
real(kind=real_umphys)    :: cff_spread_rate = rmdi
                                      ! Rate at which CFF spreads out.
real(kind=real_umphys)    :: rhcrit(model_levels_max) = rmdi
                                      ! Critical relative humidity

real(kind=real_umphys)    :: ice_width = rmdi
                                      ! Specifies the ice content
                                      ! (in terms of a fraction of qsat_liq)
                                      ! that corresponds to a factor of
                                      ! two reduction in the width of
                                      ! the vapour distribution in the
                                      ! liquid-free part of the gridbox.
real(kind=real_umphys)    :: tau_thresh = 0.01
                                      ! Value of optical depth below
                                      ! which ice cloud is set to zero.
real(kind=real_umphys)    :: forced_cu_fac = rmdi
                                      ! Factor to tune in-cloud water
                                      ! content for forced cu
real(kind=real_umphys)    :: cloud_pc2_tol = rmdi
                                      ! PC2 threshold liquid cloud fraction
                                      ! to retain cloud (RH < RHcrit)
real(kind=real_umphys)    :: cloud_pc2_tol_2 = rmdi
                                      ! PC2 threshold liquid cloud fraction
                                      ! to retain cloud (RH > RHcrit)
real(kind=real_umphys)    :: ez_max_bm = rmdi
                                      ! Maximum entrainment zone depth (m) for
                                      ! bimodal cloud scheme
real(kind=real_umphys)    :: turb_var_fac_bm = rmdi
                                      ! Dimensionless factor scales the
                                      ! turbulent unimodal variances in the
                                      ! bimodal cloud scheme
real(kind=real_umphys)    :: ent_coef_bm = rmdi
                                      ! Dimensionless entrainment coefficient
                                      ! used in parcel-based entrainment zones
                                      ! in the bimodal cloud scheme
real(kind=real_umphys)    :: max_sigmas = rmdi
                                      ! Max number of standard deviations
                                      ! to allow Gaussian s-distribution to
                                      ! extend to
! Parameters controlling height-varying minimum-allowed standard deviation
! of the s-distribution:
real(kind=real_umphys) :: min_sigx_ft = rmdi
                                      ! Max value applied aloft in the
                                      ! free-troposphere
real(kind=real_umphys) :: min_sigx_fac = 2.5
                                      ! Controls height-variation between
                                      ! the mixed-layer and free troposphere

!=======================================================================
! Constants, removed from RUN_CLOUD namelist
!=======================================================================
integer :: cloud_fraction_method   = 1
                                       ! Selects total cloud fraction
                                       ! calculation method
                                       ! 1 = minimum overlap
                                       ! 2 = variable overlap, controlled
                                       ! by overlap_ice_liquid

real(kind=real_umphys)    :: overlap_ice_liquid = -1.0
                                      ! Generic overlap parameter
                                      ! between ice and liquid phases
real(kind=real_umphys)    :: ctt_weight = 0.333
                                      ! Cloud top temperature weight
real(kind=real_umphys)    :: t_weight = 0.333
                                      ! Local temperature weight
real(kind=real_umphys)    :: qsat_fixed = 0.1e-3
                                      ! Prescribed qsat value
real(kind=real_umphys)    :: sub_cld   = 0.225
                                      ! Scaling factor
real(kind=real_umphys)    :: ceilometer_range = 6.0e3
                                      ! Max range of ceilometers used
                                      ! in filtered cloud diagnostics

!=======================================================================
! Control options, removed from namelist
!=======================================================================

logical, parameter :: l_pc2_reset = .false. ! Run PC2 scheme diagnostically

logical, parameter :: l_fixbug_pc2_qcl_incr = .true.
                                 ! Prevent QCL incr removing more
                                 ! QCL than there is, down at the
                                 ! individual subroutine level.
logical, parameter :: l_fixbug_pc2_mixph = .true.
                                 ! Collection of bug-fixes related
                                 ! to how PC2 treats mixed phase
                                 ! cloud fraction

!----------------------------------------------------------------------
!
!----------------------------------------------------------------------

! Define the RUN_CLOUD namelist

namelist/RUN_Cloud/ rhcrit, i_eacf, forced_cu, forced_cu_fac,                  &
       cloud_pc2_tol, cloud_pc2_tol_2,                                         &
       dbsdtbs_turb_0, falliceshear_method,                                    &
       l_ensure_min_in_cloud_qcf,                                              &
       i_pc2_conv_coupling, i_pc2_erosion_method, i_pc2_erosion_numerics,      &
       l_micro_eros,                                                           &
       starticeTKelvin, alliceTdegC, cff_spread_rate, ice_width,               &
       turb_var_fac_bm, ent_coef_bm, max_sigmas, min_sigx_ft,                  &
       i_cld_area, i_cld_vn, l_pc2_lbc, i_rhcpt,                               &
       l_add_cca_to_mcica,                                                     &
       l_od_cld_filter, tau_thresh,                                            &
       l_ceil_cld_filter, l_sharpen_cbh_diags, l_pc2_check_init,               &
       l_subgrid_qv, l_pc2_sl_advection,                                       &
       l_pc2_homog_conv_pressure,                                              &
       l_cloud_call_b4_conv, i_pc2_homog_g_method,                             &
       i_pc2_checks_cld_frac_method,                                           &
       ice_fraction_method, i_pc2_init_method,i_pc2_init_logic,                &
       ez_max_bm, i_bm_ez_opt, l_bm_sigma_s_grad, l_bm_tweaks

!DrHook-related parameters
integer(kind=jpim), parameter, private :: zhook_in  = 0
integer(kind=jpim), parameter, private :: zhook_out = 1

character(len=*), parameter, private :: ModuleName='CLOUD_INPUTS_MOD'

contains

subroutine check_run_cloud()

! Description:
!   Subroutine to apply logic checks based on the options selected in
!   the run_cloud namelist.

use bl_option_mod, only: off, on
use ereport_mod,    only: ereport
use pc2_constants_mod, only: acf_off, acf_cusack, acf_brooks,                  &
       rhcpt_off, rhcpt_tke_based, i_cld_pc2,                                  &
       i_cld_off, i_cld_smith, i_cld_bimodal,                                  &
       i_pc2_homog_g_cf, i_pc2_homog_g_width,                                  &
       pc2eros_exp_rh, pc2eros_hybrid_sidesonly,                               &
       i_pc2_erosion_explicit, i_pc2_erosion_implicit, i_pc2_erosion_analytic, &
       pc2init_smith, pc2init_bimodal,                                         &
       pc2init_logic_original, pc2init_logic_simplified, pc2init_logic_smooth, &
       cbl_and_cu, forced_cu_cca
use cv_run_mod, only: i_convection_vn, i_convection_vn_5a, i_convection_vn_6a, &
                      i_cv_comorph, l_param_conv
use chk_opts_mod, only: chk_var, def_src

implicit none

integer                       :: icode         ! used for ereport
character (len=errormessagelength)      :: cmessage      ! used for ereport
character (len=*), parameter  :: RoutineName = 'CHECK_RUN_CLOUD'

real(kind=jprb)               :: zhook_handle

if (lhook) call dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
def_src = RoutineName

! check the cloud scheme chosen is sensible
call chk_var(i_cld_vn,'i_cld_vn',                                              &
     [i_cld_off,i_cld_smith,i_cld_pc2,i_cld_bimodal])

if (i_cld_vn > i_cld_off) then
  call chk_var(i_cld_area,'i_cld_area',[acf_off,acf_cusack,acf_brooks])
end if

if (i_cld_vn > i_cld_smith) then
  call chk_var( ez_max_bm,    'ez_max_bm', '[250.0:750.0]' )
end if

call chk_var(i_rhcpt,'i_rhcpt',[rhcpt_off,rhcpt_tke_based])

call chk_var(ice_fraction_method,'ice_fraction_method',                        &
     [smith_orig,cloud_top_temp,min_liq_overlap,min_liq_overlap_local])

if ( i_cld_vn == i_cld_pc2) then

  call chk_var(i_pc2_homog_g_method,'i_pc2_homog_g_method',                    &
               [i_pc2_homog_g_cf, i_pc2_homog_g_width])

  call chk_var(i_pc2_erosion_method,'i_pc2_erosion_method',                    &
       [pc2eros_exp_rh, pc2eros_hybrid_sidesonly])

  call chk_var(i_pc2_erosion_numerics,'i_pc2_erosion_numerics',                &
       [i_pc2_erosion_explicit, i_pc2_erosion_implicit,                        &
        i_pc2_erosion_analytic])

  call chk_var(i_pc2_init_method,'i_pc2_init_method',                          &
       [pc2init_smith, pc2init_bimodal])

  call chk_var(i_pc2_init_logic,'i_pc2_init_logic',                            &
       [pc2init_logic_original, pc2init_logic_simplified,                      &
        pc2init_logic_smooth])

  call chk_var(forced_cu,'forced_cu',                                          &
       [off, on, cbl_and_cu, forced_cu_cca])

else
  forced_cu = off
  cmessage =                                                                   &
  'WARNING: forced_cu set to off since pc2 is off'
  icode = -100
  call ereport(RoutineName, icode, cmessage)

  call chk_var(i_eacf,'i_eacf',[0,all_clouds,not_mixph])

end if

if ( i_cld_vn==i_cld_bimodal .or.                                              &
     ( i_cld_vn==i_cld_pc2 .and. i_pc2_init_method==pc2init_bimodal ) ) then
  call chk_var(i_bm_ez_opt,'i_bm_ez_opt',                                      &
       [i_bm_ez_orig, i_bm_ez_subcrit, i_bm_ez_entpar])
end if

call chk_var(cloud_pc2_tol,  'cloud_pc2_tol',   '[1.0E-12:1.0E-1]')
call chk_var(cloud_pc2_tol_2,'cloud_pc2_tol_2', '[1.0E-12:1.0E-1]')
if ( cloud_pc2_tol_2 > cloud_pc2_tol ) then
  write(cmessage,"(A,2(A,ES10.3))")                                            &
    "Setting cloud_pc2_tol_2 > cloud_pc2_tol is not consistent. ",             &
    " cloud_pc2_tol = ", cloud_pc2_tol, " cloud_pc2_tol_2 = ", cloud_pc2_tol_2
  icode = 100
  call ereport(RoutineName, icode, cmessage)
end if

! Option l_pc2_homog_conv_pressure can only be used with a convection
! scheme that outputs an environmental subsidence pressure increment.
if ( l_pc2_homog_conv_pressure ) then
  if ( .not. ( l_param_conv .and.                                              &
               ( i_convection_vn==i_convection_vn_5a .or.                      &
                 i_convection_vn==i_convection_vn_6a .or.                      &
                 i_convection_vn==i_cv_comorph ) )   ) then
    write(cmessage,"(A)")                                                      &
      "Error: PC2 cloud scheme setting l_pc2_homog_conv_pressure " //          &
      "is only suitable for use with a mass-flux convection scheme."
    icode = 100
    call ereport(RoutineName, icode, cmessage)
  end if
end if

def_src = ''
if (lhook) call dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
return
end subroutine check_run_cloud

subroutine print_nlist_run_cloud()
use nlsizes_namelist_mod, only: model_levels
use umPrintMgr, only: umPrint
implicit none
character(len=50000) :: lineBuffer
real(kind=jprb)      :: zhook_handle
integer              :: i, rh_lev

character(len=*), parameter :: RoutineName='PRINT_NLIST_RUN_CLOUD'

if (lhook) call dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)

call umPrint('Contents of namelist run_cloud',                                 &
    src='cloud_inputs_mod')
if (model_levels > 0) then ! model_levels has been set
  write(lineBuffer,'(A,I0)')' For Reference: model_levels = ',model_levels
  call umPrint(lineBuffer,src='cloud_inputs_mod')
  do i = 1,(model_levels+7)/8
    write(lineBuffer,'(A,I0,A,I0,A,8(F0.5,1X))') ' lev ',8*i-7,'-',            &
          min(8*i,model_levels),' rhcrit=',rhcrit(8*i-7:min(8*i,model_levels))
    call umPrint(lineBuffer,src='cloud_inputs_mod')
  end do
else ! model_levels not yet read
  rh_lev = count( abs(rhcrit-rmdi) > real_eps )
  write(lineBuffer,'(A,I0)')' For Reference: no. of rhcrit inputs = ',rh_lev
  call umPrint(lineBuffer,src='cloud_inputs_mod')
  do i = 1,(rh_lev+7)/8
    write(lineBuffer,'(A,I0,A,I0,A,8(F0.5,1X))') ' lev ',8*i-7,'-',            &
          min(8*i,rh_lev),' rhcrit=',rhcrit(8*i-7:min(8*i,rh_lev))
    call umPrint(lineBuffer,src='cloud_inputs_mod')
  end do
end if
write(lineBuffer,'(A,I0)')' i_eacf = ',i_eacf
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' forced_cu = ',forced_cu
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,F0.4)')' forced_cu_fac = ',forced_cu_fac
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,ES10.3)')' cloud_pc2_tol = ',cloud_pc2_tol
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,ES10.3)')' cloud_pc2_tol_2 = ',cloud_pc2_tol_2
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,F0.4)')' dbsdtbs_turb_0 = ',dbsdtbs_turb_0
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' falliceshear_method = ',falliceshear_method
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_ensure_min_in_cloud_qcf = ',                     &
                            l_ensure_min_in_cloud_qcf
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_pc2_check_init = ',l_pc2_check_init
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' i_pc2_conv_coupling = ',i_pc2_conv_coupling
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' i_pc2_erosion_method = ',i_pc2_erosion_method
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' i_pc2_erosion_numerics = ',i_pc2_erosion_numerics
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_micro_eros = ',l_micro_eros
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,F0.4)')' starticeTKelvin = ',starticeTKelvin
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,F0.4)')' alliceTdegC = ',alliceTdegC
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,F0.4)')' cff_spread_rate = ',cff_spread_rate
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,F0.4)')' ice_width = ',ice_width
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,F0.4)')' turb_var_fac_bm = ',turb_var_fac_bm
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,F0.4)')' ent_coef_bm = ',ent_coef_bm
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,F0.4)')' max_sigmas = ',max_sigmas
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,F0.4)')' min_sigx_ft = ',min_sigx_ft
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' i_cld_area = ',i_cld_area
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' i_cld_vn = ',i_cld_vn
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_pc2_lbc = ',l_pc2_lbc
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' i_rhcpt = ',i_rhcpt
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_add_cca_to_mcica = ',l_add_cca_to_mcica
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_od_cld_filter = ',l_od_cld_filter
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,F0.4)')' tau_thresh = ',tau_thresh
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,F0.4)')' ez_max_bm = ',ez_max_bm
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_ceil_cld_filter = ',l_ceil_cld_filter
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_sharpen_cbh_diags = ',l_sharpen_cbh_diags
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_subgrid_qv = ',l_subgrid_qv
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_pc2_sl_advection = ', l_pc2_sl_advection
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_pc2_homog_conv_pressure = ',                     &
                            l_pc2_homog_conv_pressure
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_cloud_call_b4_conv = ',  l_cloud_call_b4_conv
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' i_pc2_homog_g_method = ',                          &
                            i_pc2_homog_g_method
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' i_pc2_checks_cld_frac_method = ',                  &
                            i_pc2_checks_cld_frac_method
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' ice_fraction_method = ',ice_fraction_method
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' i_pc2_init_method = ',i_pc2_init_method
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' i_pc2_init_logic = ',i_pc2_init_logic
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,I0)')' i_bm_ez_opt = ',i_bm_ez_opt
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_bm_sigma_s_grad = ',l_bm_sigma_s_grad
call umPrint(lineBuffer,src='cloud_inputs_mod')
write(lineBuffer,'(A,L1)')' l_bm_tweaks = ',l_bm_tweaks
call umPrint(lineBuffer,src='cloud_inputs_mod')

call umPrint('- - - - - - end of namelist - - - - - -',                        &
    src='cloud_inputs_mod')

if (lhook) call dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)

end subroutine print_nlist_run_cloud


end module cloud_inputs_mod
