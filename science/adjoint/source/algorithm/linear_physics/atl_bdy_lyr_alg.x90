!-----------------------------------------------------------------------------
! (c) Crown copyright 2026 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be brief.
!-----------------------------------------------------------------------------
!> @brief (Adjoint of) given TL state(igh_u) compute TLM boundary layer increment u_bl_inc
module atl_bdy_lyr_alg_mod

  use constants_mod,                       only: r_def, i_def, l_def
  use field_collection_mod,                only: field_collection_type
  use integer_field_mod,                   only: integer_field_type
  use driver_modeldb_mod,                  only: modeldb_type
  use sci_geometric_constants_mod,         only: get_height_fe,        &
                                                 get_coordinates,      &
                                                 get_panel_id,         &
                                                 get_face_selector_ew, &
                                                 get_face_selector_ns
  use sci_fem_constants_mod,               only: get_mass_matrix_fe, &
                                                 get_rmultiplicity_fe
  use  sci_field_bundle_builtins_mod,      only: clone_bundle, copy_bundle
  use field_mod,                           only: field_type
  use linear_config_mod,                   only: log_layer,        &
                                                 Blevs_m,          &
                                                 e_folding_levs_m, &
                                                 u_land_m,         &
                                                 u_sea_m,          &
                                                 z_land_m,         &
                                                 z_sea_m,          &
                                                 L_0_m
  use operator_mod,                        only: operator_type
  use derived_config_mod,                  only: bundle_size
  use field_indices_mod,                   only: igh_u, igh_t, igh_d, igh_p
  use timing_mod,                          only: start_timing, stop_timing, tik, LPROF
  use reference_element_mod,               only: reference_element_type
  use mesh_mod,                            only: mesh_type
  use fs_continuity_mod,                   only: W1, W2, W3, Wtheta
  use tl_compute_qe_kernel_mod,            only: tl_compute_qe_kernel_type
  use tl_compute_aubu_kernel_mod,          only: tl_compute_aubu_kernel_type
  use atl_bl_inc_kernel_mod,               only: atl_bl_inc_kernel_type

  implicit none

  private
  public :: atl_bdy_lyr_alg

contains

!> @brief (Adjoint of) given TL state(igh_u) compute TLM boundary layer increment u_bl_inc
!> @details The stages are:
!>          1. Call tl_compute_qe_kernel_type: from LS, compute coefficients Q, E
!>          2. Call tl_compute_aubu_kernel_type: from Q,E, compute coefficients Auv, Buv_inv
!>          3. Call atl_bl_inc_kernel_type: (adjoint of) from state(igh_u) use coefficients Auv, Buv_inv to compute u_bl_inc
!>          The TLM BL scheme is described in Var Scientific Documentation Paper 55,
!>          https://wwwspice/~frva/VAR/view/var-2025.03.0/doc/VSDP55_1A.pdf
!> @param[in,out] modeldb                Structure containing the model state
!> @param[in,out] u_bl_inc               TLM boundary layer increment
!> @param[in,out] state                  The current TL model prognostic state
!> @param[in]     ls_state               Lin state for Prognostic model state
!> @param[in]     dt                     The TL model timestep length
subroutine atl_bdy_lyr_alg(modeldb, u_bl_inc, state, ls_state, dt)

  implicit none

  type(modeldb_type), target, intent(inout) :: modeldb
  type(field_type),           intent(inout) :: u_bl_inc
  type(field_type), target,   intent(inout) :: state(bundle_size)
  type(field_type), target,   intent(in)    :: ls_state(bundle_size)
  real(kind=r_def),           intent(in)    :: dt

  ! Local variables
  real(kind=r_def)    :: alpha_dt
  logical(kind=l_def) :: dlayer_rhs
  logical(kind=l_def) :: compute_eos

  type(operator_type), pointer :: mm_vel     => null(), &
                                  mm_wtheta  => null(), &
                                  mm_w3_inv  => null()

  type(field_type), pointer :: chi(:)        => null(), &
                               panel_id      => null(), &
                               geopotential  => null(), &
                               u             => null(), &
                               theta         => null(), &
                               rho           => null(), &
                               u_base        => null(), &
                               theta_base    => null(), &
                               rho_base      => null(), &
                               exner         => null(), &
                               ls_u          => null(), &
                               ls_theta      => null(), &
                               ls_rho        => null(), &
                               ls_exner      => null()

  class(reference_element_type), pointer :: reference_element => null()
  type (mesh_type),              pointer :: mesh => null()

  type( field_type ), pointer :: height_w1  => null()
  type( field_type ), pointer :: height_w2  => null()
  type( field_type ), pointer :: height_w3  => null()
  type( field_type ), pointer :: height_wth  => null()
  type( field_type ), pointer :: w2_rmultiplicity => null()

  type( field_type )          :: state_initial(bundle_size)

  type( field_collection_type ), pointer :: ls_fields
  type( field_type), pointer             ::  ls_land_fraction => null()

  ! Coefficients computed from linearisation state
  type( field_type ) :: Q
  type( field_type ) :: E
  type( field_type ) :: auv
  type( field_type ) :: buv_inv

  type(integer_field_type), pointer :: face_selector_ew => null()
  type(integer_field_type), pointer :: face_selector_ns => null()

  integer(kind=i_def), parameter :: exner_stencil_depth = 1

  integer(kind=tik) :: id

  if ( LPROF ) call start_timing( id, 'atl_bdy_lyr_alg' )

  ls_fields => modeldb%fields%get_field_collection("ls_fields")

  call ls_fields%get_field('ls_land_fraction', ls_land_fraction)

  mesh => state(igh_u)%get_mesh()

  mm_wtheta    => get_mass_matrix_fe(Wtheta, mesh%get_id())
  chi          => get_coordinates(mesh%get_id())
  panel_id     => get_panel_id(mesh%get_id())

  height_w1  => get_height_fe(W1, mesh%get_id())
  height_w2  => get_height_fe(W2, mesh%get_id())
  height_w3 => get_height_fe(W3, mesh%get_id())
  height_wth => get_height_fe(Wtheta,mesh%get_id() )

  w2_rmultiplicity => get_rmultiplicity_fe( W2, mesh%get_id() )

  face_selector_ew => get_face_selector_ew(mesh%get_id())
  face_selector_ns => get_face_selector_ns(mesh%get_id())

  dlayer_rhs = .false.
  alpha_dt = 0.5_r_def * dt
  compute_eos = .false.

  u     => state(igh_u)
  theta => state(igh_t)
  rho   => state(igh_d)
  exner => state(igh_p)

  u_base     => state(igh_u)
  theta_base => state(igh_t)
  rho_base   => state(igh_d)

  ls_u     => ls_state(igh_u)
  ls_theta => ls_state(igh_t)
  ls_rho   => ls_state(igh_d)
  ls_exner => ls_state(igh_p)

  call clone_bundle(state,state_initial , bundle_size)
  call copy_bundle(state, state_initial, bundle_size)

  call rho%copy_field_properties( Q )
  call rho%copy_field_properties( E )

  call invoke(setval_c(Q, 0.0_r_def), &
              setval_c(E, 0.0_r_def) )

  call u%copy_field_properties( auv )
  call u%copy_field_properties( buv_inv )

  call invoke(setval_c(auv, 0.0_r_def), &
              setval_c(buv_inv, 0.0_r_def) )

  call invoke ( tl_compute_qe_kernel_type(Q,                    &
                                          E,                    &
                                          ls_state(igh_d),      &
                                          height_w3, height_wth,&
                                          ls_land_fraction,     &
                                          log_layer,            &
                                          Blevs_m,              &
                                          e_folding_levs_m,     &
                                          u_land_m,             &
                                          u_sea_m,              &
                                          z_land_m,             &
                                          z_sea_m,              &
                                          L_0_m ) )

  call invoke ( tl_compute_aubu_kernel_type(auv,                  &
                                            buv_inv,              &
                                            Q,                    &
                                            E,                    &
                                            height_w2,            &
                                            w2_rmultiplicity,     &
                                            dt,                   &
                                            Blevs_m ) )

  call invoke ( atl_bl_inc_kernel_type( u_bl_inc,             &
                                        state(igh_u),         &
                                        auv,buv_inv,          &
                                        face_selector_ew,     &
                                        face_selector_ns,     &
                                        Blevs_m ) )

  nullify( mm_vel, mm_wtheta, mm_w3_inv,       &
           chi, panel_id,                      &
           geopotential, u, theta, rho, exner, &
           mesh, reference_element )

  if ( LPROF ) call stop_timing( id, 'atl_bdy_lyr_alg' )

end subroutine atl_bdy_lyr_alg

end module atl_bdy_lyr_alg_mod
